	.data
strd:	.asciz	" %u "
strx:	.asciz	" %x "
nl:	.asciz	"\n"

length: .byte   0x0A
tab:	.byte   0xFF, 0x0A, 0x00, 0xB0, 0x01, 0xE0, 0xFF, 0xB0, 0x04, 0x50
	
	.align	2

	.text
	.globl	main

// point d'entree du programme

main:	stmfd	sp!,{lr}

	bl 	affi
	ldr	r0,=tab
	ldr	r2,=length
	ldrb	r2,[r2]
	sub	r2,r2,#1
	mov	r1,#0
	bl	quick	
	bl	affi

	mov	r0,#0
	ldmfd	sp!,{pc}	
// parametres:
// r0 = tab = T cf pseudo code
// r1 = i
// r2 = j
// pas de registres modifies, seulement la memoire. 

quick:	stmfd	sp!,{r0-r11,lr}
	cmp	r1,r2
	bhs	1f
	mov	r3,r0
	mov	r4,r1
	mov	r5,r2
	bl	part
	mov	r2,r0
	sub	r2,r2,#1
	mov	r0,r3
	bl	quick
	add	r1,r2,#2
	mov	r2,r5
	bl	quick
1:	ldmfd	sp!,{r0-r11,pc}	



// affiche le tableau sous forme de nombres hexadecimaux de 1 byte
// qui debute a tab: et contient length: elements:
// pas d'arguments d'entree
// pas d'arguments de sortie

affi:	stmfd	sp!,{r0-r11,lr}	
	ldr	r6,=length
        ldrb    r6,[r6]


	ldr	r0,=strx
	mov	r1,r6
	bl	printf


        cmp     r3,#0
        beq	2f		// tableau vide
	sub	r6,r6,#1

	ldr	r0,=nl
	bl	printf

	mov	r4,#0
	ldr	r5,=tab
        ldr	r0,=strd
1:      ldrb	r1,[r5,r4]	// nombres non signes
	stmfd	sp!,{r0}
	bl	printf	
	ldmfd	sp!,{r0}
	add	r4,r4,#1
	cmp	r4,r6
	bls	1b

	ldr	r0,=nl
	bl	printf

2:	ldmfd	sp!,{r0-r11,pc}




// accepte comme parametres 
// r0 = T pointeur sur le tableau
// r1 = i cf pseudo code
// r2 = j cf pseudo code
//
// retour
// r0 = p cf pseudo code

part:	stmfd 	sp!,{r1-r6,lr}
	
	mov	r3,r1		// k = r3 = i
1:	cmp	r3,r2		// k <= j-1
	bhs	2f		// sortie de la boucle for
	ldrb	r4,[r0,r3]	// r4 = T[k]
	ldrb	r5,[r0,r2]	// r5 = T[j]
	cmp	r5,r4
	ldrhib	r6,[r0,r1]	// r6 = T[i]
	strhib	r6,[r0,r3]	// swap T[i] <-> T[k]
	strhib	r4,[r0,r1]
	addhi	r1,r1,#1
	add	r3,r3,#1	// k = k+1
	b	1b
2:	ldrb	r6,[r0,r1]	// r6 = T[i]
	ldrb	r5,[r0,r2]
	strb	r6,[r0,r2]	// swap T[j] <-> T[i]
	strb	r5,[r0,r1]
	mov	r0,r1	
	ldmfd	sp!,{r1-r6,lr}
	mov	pc,lr
